1. 디자인 패턴이란?
- 어떤 상황의 문제에 대한 해법
- 패턴 이름 : 한두 단어로 설계 문제와 해법을 서술 한다
- 문제 : 언제 패턴을 사용하는가를 서술하며 해결할 문제와 그 배경을 설명한다
- 해법 : 설계를 구성하는 요소들과 그 요소들 간의 관계, 책임 그리고 협력 관계를 서술한다
- 결과 : 디자인 패턴을 적용해서 얻은 결과와 장단점을 서술한다 

2. 서몰토크 MVC를 사용한 디자인 패턴
- Model : 응용프로그램 객체
- View : 스크린에 모델을 디스플레이 하는 방법
- Controller : 사용자 인터페이스가 사용자 입력에 반응하는 방법
- 뷰와 모델간에 등록/통지(subscribe/notify)프로토콜을 만들어 종속성을 없앱니다
- 즉, 한객체에서 일어난 변경을 다른 객체들에 반영하도록 별도의 객체를 둠으로써, 변경이 일어난 객체는 변경 반영이 필요한
  다른 객체들을 알 필요가 없게끔 객체를 분리한다 -> 감시자 패턴 
- 시각적 표현 방법의 변경 없이 사용자 입력에 대한 뷰의 반응 방법을 변경할 수 있다
- Controller를 이용하여 반응 방법을 캡슐화 한다

3. 디자인 패턴 기술 하기
- 패턴 이름과 분류 : 하나의 패턴에 붙은 이름은 그 자체가 핵심을 간결하게 전달해 준다
- 의도 : 이 디자인 패턴이 무엇을 하는지, 논리적 근거는 무엇인지, 어떤 문제를 해결 하는지 에 대한 대답
- 다른 이름 : 다르게 부르는 이름
- 동기 : 설계 문제를 제시하고, 패턴 안에서 클래스나 객체 구조가 어떻게 문제를 해결하는지 설명해 주는 일종의 시나리오
- 활용성 : 어떤 상황에 적용 할 수 있는지에 대한 대답
- 구조 : 객체 모델링 기법에 기반을 둔 표기법을 이용해여 해당 패턴에서 쓰는 클래스들을 시각적으로 나타내는 것
- 참여자 : 주어진 패턴을 구성하고 책임을 수행하느 클래스나 객체들을 설명한다
- 협력 방법 : 참여자들이 작업을 수행하기 위한 참여자들 간의 협력 관계를 설명
- 결과 : 패턴을 이용한 결과
- 구현 : 태펀을 구현할 때 주의해야 할 함정, 힌트, 기법
- 예제 코드 : 주어진 패턴을 어떻게 구현 할 수 있는가를 보여주는 코드
- 잘 알려진 사용예 - 실제 시스템에서 찾아볼 수 있는 패턴
- 관련 패턴 : 이 패턴과 밀접하게 관련된 다른 패턴들과의 차이점 

5. 카탈로그(디자인패턴) 조직화

        생성            구조가          행동
클래스   팩토리 메서드      적응자          해석자
                                     템플릿 메서드
객체     추상 팩토리       적응자         책임 연쇄
        빌더            가교           명령
        원형            복합체         중재자
        단일체           장식자         메멘토
                       퍼사드         감시자
                       플라이급        상태
                       프록시          전략
                                     방문자

- 클래스, 객체
-> 패턴을 주로 클래스에 적용하는지 아니면 객체에 적용 하는지를 구분
- 클래스 패턴
-> 클래스와 서브클래스 간의 관련성을 다루는 패턴 (상속)
- 객체 패턴
-> 객체 관련성을 다루는 패턴으로서, 런타임에 변경 할 수 있으며 더 동적인 성격을 가진다                                     

- 생성 클래스
-> 객체를 생성하는 책임의 일부를 서브클래스가 담당 하도록 한다
- 생성 객체
-> 객체 생성을 다른 객체에게 위임한다

- 구조 클래스
-> 상속을 이용해서 클래스를 복합한다
- 구조 객체
-> 객체를 합성하는 방법의 정의

- 행동 클래스
-> 상속을 이용해서 알고리즘 제어 흐름일 기술 한다
- 행동 객체
-> 하나의작업을 수행하기 위해 객체 집합이 어떻게 협력하는지를 기술한다

6. 디자인 패턴을 이용하여 문제를 푸는 방법
- 적당한 객체 찾기
-> 객체는 테이터와 이 테이터에 연산을 가하는 프로시저를 함께 묶은 단위이다
-> 프로시저는 일반적으로 메서드 또는 여산이라고 한다
-> 객체는 요청 또는 메시지를 사용자에게 받으면 연산을 수행한다
-> 요청은 객체가 연산을 실행하게 하는 유일한 방법이고, 연산은 객체 내부 데이터의 상태를 변경하는 유일한 방법이다 
   -> 캡슐화 : 객체 외부에서는 객체 내부 데이터에 직접 접근할 수 없고, 객체의 내부 데이터 표현 방법을 알 수 없다

- 객체의 크기 결정 
-> 디자인 패턴에서 이 문제의 답을 얻을 수 있다

- 객체 인터페이스의 명세
-> 객체가 선언하는 모든 연산은 연산의 이름, 매개변수로 받아들이는 객체들, 연산의 반환값을 명세한다 (시그니쳐라고 한다)
-> 인터페이스는 객체가 정의하는 연산의 모든 시그니처들을 일컫는 말이다(객채가 선언하는 연산만)
-> 즉, 인터페이스는 객체가 받아서 처리할 수 있는 연산의 집합이다

- 타입
-> 타입은 특정 인터페이스를 나타낼 때 사용하는 이름이다
-> 객체가 Window타입을 갖는다는 것은 Window인터페이스에 정의한 모든 연산들을 처리 할 수 있다는 뜻이다
-> A인터페이스가 B인터페이스의 부분집합일 경우 A인터페이스는 B인터페이스의 서브 타입이다 (반대는 슈퍼타입)
-> 즉, 서브타입은 슈퍼타입의 인터페이스를 상속 한다
-> OOP에서 외부에서 객체를 알 수 있는 방법은 인터페이스 밖에 없기 때문에 인터페이스를 통해서만 처리를 요청 할 수 있다
-> 객체에 요청이 전달되면, 요청과 이를 받는 개체에 따라서 수행되는 처리 방식이 달라진다
   -> 오버라아딩, 오버로딩 같은 걸로 런다음에서 처리 방식을 달리 한다 -> 동적 바인딩 -> 이를 통해서 다형성이 확보 된다

- 객체 구현 명세하기
-> 객체는 클래스를 인스턴스로 만듦으로써 생성된다
-> 즉, 객체는 클래스의 인스턴스라고 할 수 있다
-> 인스턴스화 과정은 객체의 내부 데이터 변수에 대한 공간을 항당하고, 이 데이터들을 연산과 관련 짓는 것이다 (인스턴스화 과정)
-> 추상 클래스
   -> 추상 클래스는 모든 서브 클래스 사이의 공통되는 인터페이스를 정의 한다
   -> 추상 클래스는 정의한 모든 연산이나 일부 연산의 구현을 서브클래스에게 넘긴다
   -> 정의한 연산 모두가 추상 클래스로 구현된 것이 아니므로, 추상 클래스는 인스턴스를 생성할 수 없다
   -> 추상 클래스가 아닌 클래스를 구체 클래스(concrete class)라고 한다

- 클래스와 타입의 차이
- 클래스
-> 객체의 클래스는 그 객체가 어떻게 구현되느냐를 정의한다
-> 클래스는 객체의 내부 상태와 그 객체의 여산에 대한 구현 방법을 정의한다
- 타입
-> 객체의 인터페이스, 즉 그 객체가 응답할 수 있는 요청의 집합을 정의한다

- 상속과 인터페이스(구현)의 차이
- 상속
-> 상속은 객체의 구현을 정의할 때 이미 정의된 객체의 구현을 바탕으로 한다
-> 즉, 코드와 내부 표현 구조를 공유하는 메커니즘이다
- 인터페이스
-> 어떤 객체가 다른 객체 대신에 사용될 수 있는 경우를 지정하는 메커니즘이다

- 구현에 따르지 않고, 인터페이스에 따르는 프로그래밍
-> 상속은 기본적으로 부모 클래스에서 정의한 구현을 재사용하여 응용프로그램의 기능성을 확장하려는 메카니즘이다
-> 동일한 인터페이스를 갖는 객체군을 정의 한다 -> 다형성을 끌어낼 수 있다
   -> 상속을 적절하게 이용하면, 모든 클래스는 추상 클래스를 상속하도록 하여 인터페이스를 공유할 수 있게 된다
   -> 서브클래스가 단순히 연산을 추가하거나 재정의할뿐, 부모 클래스의 연산을 감추지 않는다는 뜻
   1. 사용자가 원하는 인터페이스를 그 객체가 만족하고 있는 한, 사용자는 그들이 사용하는 특정 객체 타입에 대해 알아야 할 필요는 없다
   2. 사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고, 단지 인터페이스를 정의하는 추상 클래스가 무엇인지만 알면 된다
   결론, 구현이 아닌 인터페이스에 따라 프로그래밍 한다는 원칙이 생긴다
   따라서, 어떤 변수(객체)를 구체 클래스의 인스턴스로 선언하는 일은 피해야 한다. 대신 추상 클래싕 인터페이스를 따르는 인스턴스 변수를 정의해야 한다

- 재사용을 실현 가능한 것으로
- 상속 대 합성
- 상속
-> OOP에서 기능의 재사용을 위해 구사하는가장 대표적인 기법은 클래상속, 그리고 객체 합성(object composition)이다
-> 클래스 상속은 서브클래싱, 즉 다른 부모 클래스에서 상속받아 한 클래스의 구현을 정의하는 것
   -> 서브클래싱에 의한 재사용을 화이트박스 재사용이라고 한다(내부를 볼 수 있다는 의미)
   -> 상속을 받으면 부모 클래스의 내부가 서브클래스에 공개 되기 때문이다
   -> 컴파일 시점에 정적으로 정의되고 프로그래밍 언어가 직접 지원하므로 그대로 사용하면 된다
   -> 런타임에 상속받은 부모 클래스의 구현을 변경할 수 없다(상속은 컴파일 시점에 결정 되는 사항이기 때문)
   -> 부모 클래스의 구현에 종속 될 수 박에 없으므로, 부모 클래스 구현에 변경이 생기면 서브클래스도 변경 해야 한다
   -> 서브클래스를 재사용하려고 할 때 문자가 발생한다 상속한 구현이 새로운 문제에 맞지 않을때, 부모클래스를 재작성해야 한다
      -> 추상 클래스에서만 상속을 받아서 해결한다 (구현이 거의 없거나 아예 없기때문)
- 객체 합성 
-> 객체 합성은 클래스 상속에 대한 대안이다
-> 다른 객체를 여러 개 붙여서 새로운 기능 혹은 객체를 구성하는 것이다
-> 객체를 합성하려면, 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해야 한다
   -> 이런 스타일의 재사용을 블랙박스 재사용이라고 한다
   -> 객체 내부는 공개되지 않고 인터페이스를 통해서만 재사용 되기 때문이다
   -> 한객체가 다른 객체에 대한 참조자를 얻는 방식으로 런타임에 동적으로 정의된다
   -> 객체가 다른 객체의 인터페이스만을 바라보게 하기 때문에, 인터페이스 정의에 더 많은 주의를 기울여야 한다
   -> 객체는 인터페이스에만 접근하므로 캡슐화를 유지할 수 있다
   -> 객체는 인터페이스에 맞춰 구현되므로 구현 사이의 종속성은 확실히 줄어든다
결론, 객체 합성이 클래스 상속보다 더 나은 방법이다

- 위임
-> 합성을 상속만큼 강력하게 만드는 방법
-> 위임에서는 두 객체가 하나의 요청을 처리한다
-> 수신 객체가 연산의 처리를 위임자(delegate)에게 보낸다 (서브클래스가 부모 클래스에게 요청을 전달하는 것과 유사하다)
-> Window 클래스를 Rectangle클래스의 서브 클래스로 만드는 대신, Window 클래스는 Rectangle 클래스를 자신의 인스턴스로 만들고
   Rectagle에 정의된 행동이 필요할 때는 Rectangle클래스에 위임함으로써 Rectangle의 행동을 재사용하는 방법
-> 즉, 상속에 의해 window인스턴스를 포함 Rectangle인스턴스로 간주하는 방식이 아닌, Window인스턴스가 Rectagle인스턴를
   포함 하도록 하고 Window인스턴스는 자신이 받은 요청을 Rectangle인스턴스로 전달하는 방식
-> 런타임에 행동의 복합을 가능하게하고, 복합하는 방식도 변경해 준다
-> 고도로 매개변수화된 소프트웨어는 정적인 소프트웨어구조보다 이해하기가 어렵다

- 상속 대 매개변수화된 타입
-> 기능의 재사용에 이용할 수 있는 다른 방법이 매개변수화된 타입(parametrized type)이다 (제네릭이라고도 한다)
-> 타입을 정의할 때 타입이 사용하는 다른 모든 타입을 다 지정하지 않은 채 정의한다
-> 미리 정의하지 않은 타입은 매개변수로 제공한다

- OOP에서 행동을 복합할수 있는 3가지 방법 -> 상속, 합성, 제네릭
- 합성
-> 런타임에 행동을 변경할 수 있지만, 해동이 위임되기 때문에 비효율적일수 있다
- 상속
-> 연산에 대한 기본 행동을 부모 클래스가 제공하고 이를 서브클래스에서 재정의하도록 하는 것
- 제네릭
-> 클래스가 사용하는 타입을 변경하게 하는 것

- 디자인 패턴을 적용 할 수 있는 케이스들
- 1. 특정 클래스에서 객체 생성
- 객체를 생성 할 때 클래스 이름을 명시하면 어떤 특정 인터페이스가 아닌 어떤 특정 구현에 종속 된다
- 이런 종속은 앞으로의 변화를 수용하지 못하고 이를 방지 하기 위해서는 객체를 직접 생성해서는 안된다
-> 추상 팩토리, 팩토리 메서드, 원형

- 2. 특정 연산에 대한 의존성
- 특정한 연산을 사용하면 요청을 만족하는 한가지 방법에만 메이게 된다
- 요청의 처리 방법을 직접 코딩하는 방식을 피하면, 컴파일 시점과 런타임 모두 만족하면서 요청 처리 방법을 쉽게 변경 할 수 있다
-> 책임 연쇄, 명령

- 3. 하드웨어와 소프트웨어 플랫폼에 대한 의존성
- 기존에 존재하는 시스템 인터페이스와 응용프로그램 프로그래밍 인터페이스는 소프트웨어 및 하드웨어 플랫폼 마다 모두 다른다
- 특정 플랫폼에 종속된 소프트웨어는 다른 플랫폼에 이식 하기도 어렵다
- 또한 본래의 플랫폼에서도 버전의 변경을 따라가기가 어렵다
- 플랫폼 종속성을 제거 하고 싶다
-> 추상 팩토리, 가교

- 4. 객체의 표현이나 구현에 대한 의존성
- 사용자가 객체의 표현 방법, 저장 방법, 구현 방법, 존재의 위치에 대한 모든 방법을 하고 있다면 객체를 변경할 때 사용자도 함께 변경해야 한다
- 이런 정보를 사용자에게 감춤으로써 변화의 파급을 막을 수 있다
-> 추상 팩토리, 가교, 메멘토, 프록시

- 5. 알고리즘 의존성
- 알고리즘 자체를 확장할 수도, 최적화할 수도 다른 것으로 대체 할 수도 있는데, 알고르즘에 종속된 객체라면 알고리즘이 변할 때 마다
  객체도 변경해야 한다 
- 따라서, 변경이 가능한 알고르즘을 분리 해내고 싶다
-> 반복자, 전략, 템플릿 메서드, 방문자

- 6. 높은 결합도
- 높은 결합도를 갖는 클래스들은 독립적으로 재사용 하기 어렵다
- 높은 결합도를 갖게되면 하나의 커다란 시스템이 되어 버리고, 이렇게 되면 클래스 하나를 수정하기 위해서 전체를 이해해야 한다
- 이식은 커녕 유지 보수조차 어려워 진다
-> 추상 팩토리, 가교, 책임 연쇄, 명령, 퍼사드, 중재자, 감시자

- 7. 서브클래싱을 통한 기능 확장
- 서브클래싱으로 객체를 재정의하는 것은 쉬운 일이 아니다.
- 새로운 클래스 마다 매번 반드시 해야하는 초기화, 소멸 등에 대한 구현 오버헤드를 늘 지게 된다
- 서브클래스를 정의하려면 최상위 클래스부터 자신의 직속 부모 클래스까지 모든 것을 이해 해야 한다
- 또한 단순히 확장만을 이유로 새로운 서브클래스를 만든다면 서브클래싱은 클래스의 수를 엄청나게 증가 시킬 가능성이 있다
- 서브클래스를 정의하지 않고 합성과 위음으로 새로운 기능을 추가 하고 싶다
- 하지만 객체 합성을 많이 사용한 시스템은 이해하기가 어려워 진다
- 따라서 서브클래스를 정의하고 다른 인스턴스와 새로 정의한 클래스의 인스턴스를 합성해서 기능을 재정의 하고 싶다
-> 가교, 책임 연쇄, 장식자, 감시자, 전략

- 8. 클래스 변경이 편하지 못한 점
- 가끔 클래스를 변경하는 작업이 그렇게 단순하지 않을 때가 ㅁ낳다
- 소스 코드가 필요한데 없을 수도 있다, 또는 어떤 변경을 하면 기존 서브클래스의 다수를 수정 해야 할 수도 있다
-> 적응자, 장식자, 방문자

- 디자인 패턴을 고르는 방법
- 1. 패턴이 어떻게 문제를 해결하는지 파악해라
- 2. 패턴의 의도 부분을 보자
-> 패턴의 의도를 읽어보고 갖고 있는 문제와 비슷한지 맞춰봐라
- 3. 패턴들 간의 관련성을 파악해라
-> 관련성을 파악함으로써 올바른 패턴을 하나 또는 그룹으로 선택 할 수 있다
- 4. 비슷한 목적의 패턴들을 모아서 공부해라
-> 패턴들 간의 유사점과 차이점을 이해 하면 선택에 도움이 된다
- 5. 재설계의 원인을 파악해라
- 6. 설계에서 가변성을 가져야 하는 부분이 무엇인지 파악해라
-> 무엇이 설계를 변경하는지 파악하는 것이 아니라, 재설계 없이 변경하고 싶은 부분이 무엇인지 파악해라
-> 이로써, 가변성을 갖는 부분을 별도의 개념으로 캡슐화 한다

- 디자인 패턴 사용 방법
- 생성
  디자인 패턴         이 패턴을 통해 다양화할 수 있는 부분
- 1. 추상 팩토리     -> 제품 객체군
- 2. 빌더          -> 복합 객체 생성 방법
- 3. 팩토리 매서드    -> 인스턴스화될 객체의 서브클래스
- 4. 원형           -> 인스턴스화될 객체 클래스가
- 5. 단일체         -> 클래스의 인스턴스가 하나 일 때 

- 구조
- 1. 적응자       -> 객체에 대한 인터페이스
- 2. 가교         -> 객체 구현
- 3. 복합체       -> 객체의 합성과 구조
- 4. 장식자       -> 서브클래싱 업싱 객체의 책임성
- 5. 퍼사드       -> 서브시스템에 대한 인터페이스
- 6. 플라이급       -> 객체의 저장 비용
- 7. 프록시       -> 객체 접근 방법

- 명령
- 1. 책임 연쇄      -> 요청을 처리하는 객체
- 2. 명령          ->요청의 처리 시점과 처리 방법
- 3. 해석자       -> 언어의 문법과 해석 방버
- 4. 반복자       -> 언어의 문법과 해석 방법
- 5. 중재자       -> 어떤 객체들이 어떻게 상호작용하는지
- 6. 메멘토       -> 언제 어떤 정보를 객체의 외부에 저장 하는지를
- 7. 감시자       -> 다른 객체에 종속적인 객체수, 종속적인 객체들의 상태 변경 방법
- 8. 상태       -> 객체의 상태
- 9. 전략       -> 알고리즘
- 10. 템플릿 메서드         -> 알고리즘의 단계
- 11. 방문자        -> 클래스의 변경 없이 객체에 적용할 수 있는 연산